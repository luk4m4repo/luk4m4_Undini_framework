import unreal
import os

def reimport_datatables(iteration_number=None, csv_dir=None):
    """
    Import or reimport CSV files as DataTables in Unreal Engine
    
    This is the fourth step in the Undini procedural generation pipeline:
    1. First, we export splines from Unreal Engine (000_export_splines_as_json.py)
    2. Then, we export GenZone meshes from UE (010_export_gz_to_mod.py)
    3. Next, we process those inputs in Houdini to generate building data (100_headless_topnet_PCGHD.py)
    4. Now, we import the generated CSV files back into Unreal Engine as DataTables
    
    The script takes the CSV files generated by Houdini (mesh and material data) and imports them
    as DataTables in Unreal Engine. These DataTables will be used by the PCG system to generate
    procedural buildings in the level.
    
    Args:
        iteration_number (int, optional): The iteration number to use for file naming. Defaults to 0.
        csv_dir (str, optional): Directory containing the CSV files. If None, uses a default path.
        
    Returns:
        int: 1 if all imports were successful, 0 if any failed
    """

    # Set up our parameters with sensible defaults if not provided
    if iteration_number is None:
        iteration_number = 0
        print("‚ÑπÔ∏è No iteration number provided, using default: 0")
    else:
        print(f"‚ÑπÔ∏è Using provided iteration number: {iteration_number}")
        
    if csv_dir is None:
        # Calculate the default CSV directory based on the script location
        # This follows the same path structure as in the manager script
        workspace_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
        csv_dir = os.path.join(workspace_root, '03_GenDatas', 'Dependancies', 'PCG_HD', 'Out', 'CSV')
        print(f"‚ÑπÔ∏è No CSV directory provided, using default: {csv_dir}")
    else:
        print(f"‚ÑπÔ∏è Using provided CSV directory: {csv_dir}")
    
    # Make sure the CSV directory exists
    if not os.path.exists(csv_dir):
        print(f"‚ö†Ô∏è Warning: CSV directory does not exist: {csv_dir}")
        print("   Creating directory...")
        try:
            os.makedirs(csv_dir, exist_ok=True)
            print(f"‚úÖ Created directory: {csv_dir}")
        except Exception as e:
            print(f"‚ùå Error creating directory: {str(e)}")
            return 0
    
    # Define the UE paths for our assets
    # These are the same paths used throughout the pipeline
    ue_base_path = "/Game/luk4m4_Undini/CSV"
    
    # Define the CSV imports with the iteration number
    # Each import specifies the source CSV file, destination in UE, asset name, and template to use
    csv_imports = [
        {
            "csv_file": os.path.join(csv_dir, f"mesh_{iteration_number}.csv"),
            "destination_path": ue_base_path,
            "asset_name": f"mesh_{iteration_number}",
            "template_path": f"{ue_base_path}/mesh_template",
            "description": "Mesh data for procedural buildings"
        },
        {
            "csv_file": os.path.join(csv_dir, f"mat_{iteration_number}.csv"),
            "destination_path": ue_base_path,
            "asset_name": f"mat_{iteration_number}",
            "template_path": f"{ue_base_path}/mat_template",
            "description": "Material data for procedural buildings"
        }
    ]
    
    print("\nüìö PROCESSING DATATABLES üìö")
    print(f"Using iteration number: {iteration_number}")
    print(f"Looking for CSV files in: {csv_dir}")
    print(f"Will import to Unreal path: {ue_base_path}")
    
    # Check if the CSV files exist before we start
    missing_files = []
    for import_data in csv_imports:
        if not os.path.exists(import_data["csv_file"]):
            missing_files.append(import_data["csv_file"])
    
    if missing_files:
        print(f"\n‚ö†Ô∏è Warning: The following CSV files are missing:")
        for file in missing_files:
            print(f"   - {file}")
        print("Will attempt to import only the files that exist.")
    else:
        print(f"\n‚úÖ All required CSV files found.")

    
    # Get references to the Unreal Engine editor libraries we need
    print("\nüîç Getting Unreal Engine editor libraries...")
    editor_lib = unreal.EditorAssetLibrary
    asset_tools = unreal.AssetToolsHelpers.get_asset_tools()
    
    # Keep track of our progress
    success_count = 0
    
    # Process each CSV file to import as a DataTable
    for import_data in csv_imports:
        try:
            # Extract the import data
            csv_file = import_data["csv_file"]
            destination_path = import_data["destination_path"]
            asset_name = import_data["asset_name"]
            template_path = import_data["template_path"]
            description = import_data.get("description", "")
            full_asset_path = f"{destination_path}/{asset_name}"
            
            print(f"\nüìÇ Processing: {asset_name} ({description})")
            print(f"   Source: {csv_file}")
            print(f"   Destination: {full_asset_path}")
            
            # Skip if CSV file doesn't exist
            if not os.path.exists(csv_file):
                print(f"‚ùå Error: CSV file not found at {csv_file}")
                print("   Skipping this import and continuing with the next one.")
                continue
            
            # Check if we're creating a new asset or updating an existing one
            asset_exists = editor_lib.does_asset_exist(full_asset_path)
            if asset_exists:
                print(f"‚ÑπÔ∏è Asset already exists - will perform a reimport")
            else:
                print(f"‚ÑπÔ∏è Asset does not exist - will create a new DataTable")
            
            # Get the row structure from the template DataTable
            print(f"Looking for template at: {template_path}")
            row_struct = None
            if editor_lib.does_asset_exist(template_path):
                template_dt = editor_lib.load_asset(template_path)
                if template_dt and isinstance(template_dt, unreal.DataTable):
                    row_struct = template_dt.get_editor_property("row_struct")
                    if row_struct:
                        print(f"‚úÖ Found row struct from template: {row_struct.get_name()}")
            
            if not row_struct:
                print(f"‚ùå Error: Could not find a valid row struct for {asset_name}")
                print("   This usually means the template DataTable doesn't exist or is invalid.")
                print("   Make sure you have a valid template at: {template_path}")
                continue
            
            # Now let's set up the import task
            print("Setting up CSV import task...")
            task = unreal.AssetImportTask()
            task.filename = csv_file
            task.destination_path = destination_path
            task.destination_name = asset_name
            task.replace_existing = asset_exists
            task.automated = True  # Don't show any UI
            task.save = True       # Save the asset after import
            
            # Create and configure a CSV import factory
            csv_factory = unreal.CSVImportFactory()
            
            # Configure the import settings
            import_settings = unreal.CSVImportSettings()
            import_settings.import_type = unreal.CSVImportType.ECSV_DATA_TABLE
            
            # Different versions of UE use different property names for the row struct
            # We'll try all known variations to ensure compatibility
            try:
                # Try the property name for newer UE versions
                print("Trying newer UE property name: data_table_row_type")
                import_settings.data_table_row_type = row_struct
            except AttributeError:
                try:
                    # Try the property name for older UE versions
                    print("Trying older UE property name: import_row_struct")
                    import_settings.import_row_struct = row_struct
                except AttributeError:
                    # If both fail, we'll try setting it directly on the factory
                    print("Using direct factory property setting for row struct")
                    # Note: This might not work on all UE versions, but it's a last resort
            
            # Apply the import settings to the factory
            csv_factory.set_editor_property("automated_import_settings", import_settings)
            
            # Assign the factory to our task
            task.factory = csv_factory
            
            # Now let's perform the actual import
            print(f"\nüì• {'Reimporting' if asset_exists else 'Importing'} {asset_name}...")
            result = asset_tools.import_asset_tasks([task])
            
            # Check if the import was successful
            if result and len(result) > 0:
                print(f"‚úÖ Successfully {'reimported' if asset_exists else 'imported'} DataTable {asset_name}")
                success_count += 1
                
                # Verify the asset exists after import
                if editor_lib.does_asset_exist(full_asset_path):
                    # Try to get some info about the imported DataTable
                    try:
                        dt = editor_lib.load_asset(full_asset_path)
                        if isinstance(dt, unreal.DataTable):
                            row_count = len(dt.get_row_names())
                            print(f"   DataTable contains {row_count} rows")
                    except Exception as e:
                        # Not critical if this fails, just informational
                        print(f"   Could not get row count: {str(e)}")
                else:
                    print(f"‚ö†Ô∏è Warning: Asset reported as imported but not found at {full_asset_path}")
            else:
                # The import might have succeeded even if result is empty (UE quirk)
                if editor_lib.does_asset_exist(full_asset_path):
                    print(f"‚úÖ Import appears successful for {asset_name} - asset exists in Content Browser")
                    success_count += 1
                else:
                    print(f"‚ö†Ô∏è Import process completed for {asset_name} but asset not found - check for errors")
        except Exception as e:
            print(f"‚ùå Error processing {import_data['asset_name']}: {str(e)}")
            # Print more detailed error information to help with debugging
            import traceback
            print(f"   Error details: {traceback.format_exc()}")
            print("   Continuing with next import...")

    
    # Print a summary of what we did
    print(f"\nüìä IMPORT/REIMPORT SUMMARY üìä")
    print(f"{'=' * 40}")
    print(f"Total DataTables to process: {len(csv_imports)}")
    print(f"Successfully processed:      {success_count}")
    print(f"Failed:                      {len(csv_imports) - success_count}")
    print(f"{'=' * 40}")
    
    # Return a success code based on whether all imports succeeded
    if success_count == len(csv_imports):
        print(f"üéâ All DataTable imports completed successfully!")
        print(f"The next step is to create PCG graphs in Unreal Engine using these DataTables.")
        return 1
    elif success_count > 0:
        print(f"‚ö†Ô∏è Some DataTable imports failed. Check the log above for details.")
        print(f"You may still be able to proceed with the pipeline using the successful imports.")
        return 0
    else:
        print(f"‚ùå All DataTable imports failed. Please fix the issues before continuing.")
        print(f"Common issues include:")
        print(f"  ‚Ä¢ Missing CSV files from Houdini export")
        print(f"  ‚Ä¢ Missing template DataTables in Unreal Engine")
        print(f"  ‚Ä¢ Incorrect file paths or permissions")
        return 0
